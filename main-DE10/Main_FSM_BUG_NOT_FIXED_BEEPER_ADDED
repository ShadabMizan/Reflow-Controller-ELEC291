$MODMAX10

; The Special Function Registers below were added to 'MODMAX10' recently.
; If you are getting an error, uncomment the three lines below.

; ADC_C DATA 0xa1
; ADC_L DATA 0xa2
; ADC_H DATA 0xa3

org 0000h
    ljmp mycode
    
org 0x000B
	ljmp Timer0_ISR

org 002Bh
    ljmp Timer2_ISR

dseg at 30h
; Math32 variables
x:		ds	4
y:		ds	4
bcd:	ds	5

; PWM variables
ticks_per_sec:    ds 2        ; Tick counter for seconds
pwm_tick_counter: ds 1
pwm_on_ticks:     ds 1
pwm:              ds 1    ; 0â€“100 (% duty cycle)

; Tmp variables
ref4040: ds 4
coldj_tmp: ds 4

; FSM Variables
fsm_state: ds 1

current_tmp: ds 1
current_time: ds 1

soaktmp: ds 1
soaktime: ds 1

reflowtmp: ds 1
reflowtime: ds 1

;=====================
;==timer variables
;====================

Count1ms: ds 2 ; Used to determine when half second has passed
BCD_counter: ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop



bseg
; math32 bit
mf:		dbit 1

; PWM bit
seconds_flag: dbit 1
oven_enabled:     dbit 1      ; PWM state

CLK              EQU 33333333    ; DE10-Lite CV-8052 = 33.333 MHz
TIMER2_RATE      EQU 2048        ; 2048 Hz for a 488 u-sec period/per tick
TIMER2_RELOAD    EQU ((65536-(CLK/(12*TIMER2_RATE))))
PWM_PERIOD_TICKS EQU 20          ; 20 ticks = 9.77ms period = 102 Hz PWM

;=======================================================
;====Timer0 thing added=================
;=======================================================

TIMER0_RATE EQU 4096 ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
SOUND_OUT equ P0.1




SSR_PIN         EQU P3.7
START_BUTTON    EQU P1.5 ;35

VREF_VALUE      EQU 4116


CSEG

InitSerialPort:
    mov TMOD, #20H        ; Timer1 mode 2
    mov TH1, #0F7H          ; 9600 baud @ 33.333MHz
    mov TL1, #0F7H
    setb TR1              ; Start Timer1
    mov SCON, #50H        ; Mode 1, REN enabled
    setb TI               ; Set TI so first transmit works
    ret
  
;====================================== 
    ;TIMER INIT
;======================================

Timer0_Init:
orl CKCON, #0b00001000 ; Input for timer 0 is sysclk/1
mov a, TMOD
anl a, #0xf0 ; 11110000 Clear the bits for timer 0
orl a, #0x01 ; 00000001 Configure timer 0 as 16-timer
mov TMOD, a
mov TH0, #high(TIMER0_RELOAD)
mov TL0, #low(TIMER0_RELOAD)

; Enable the timer and interrupts
;setb ET0 ; Enable timer 0 interrupt
;setb TR0 ; Start timer 0
ret

putchar:
    JNB TI, putchar
    CLR TI
    MOV SBUF, a
    RET

SendString:
    CLR A
    MOVC A, @A+DPTR
    JZ SSDone
    LCALL putchar
    INC DPTR
    SJMP SendString
SSDone:
    ret

$include(math32.asm)

cseg
; These 'equ' must match the wiring between the DE10Lite board and the LCD!
; P0 is in connector JPIO.  Check "CV-8052 Soft Processor in the DE10Lite Board: Getting
; Started Guide" for the details.
ELCD_RS equ P1.7
; ELCD_RW equ Px.x ; Not used.  Connected to ground 
ELCD_E  equ P1.1
ELCD_D4 equ P0.7
ELCD_D5 equ P0.5
ELCD_D6 equ P0.3
ELCD_D7 equ P0.1
$NOLIST
$include(LCD_4bit_DE10Lite_no_RW.inc) ; A library of LCD related functions and utility macros
$include(pwm.inc)
$LIST

; Look-up table for 7-seg displays
myLUT:
    DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
    DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
    DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F

Wait50ms:
;33.33MHz, 1 clk per cycle: 0.03us
	mov R0, #30
Wait50ms_L3:
	mov R1, #74
Wait50ms_L2:
	mov R2, #250
Wait50ms_L1:
	djnz R2, Wait50ms_L1 ;3*250*0.03us=22.5us
    djnz R1, Wait50ms_L2 ;74*22.5us=1.665ms
    djnz R0, Wait50ms_L3 ;1.665ms*30=50ms
    ret
    
    ;---------------------------------;
; ISR for timer 0. Set to execute;
; every 1/4096Hz to generate a ;
; 2048 Hz wave at pin SOUND_OUT ;
;---------------------------------;
Timer0_ISR:
;clr TF0 ; According to the data sheet this is done for us already.
; Timer 0 doesn't have 16-bit auto-reload, so
clr TR0
mov TH0, #high(TIMER0_RELOAD)
mov TL0, #low(TIMER0_RELOAD)
setb TR0
cpl SOUND_OUT ; Connect speaker the pin assigned to 'SOUND_OUT'!
reti

Display_Voltage_7seg:
	
	mov dptr, #myLUT

    mov a, bcd+2
	swap a
	anl a, #0FH
	movc a, @a+dptr
	mov HEX5, a
	
	mov a, bcd+2
	anl a, #0FH
	movc a, @a+dptr
	mov HEX4, a

	mov a, bcd+1
	swap a
	anl a, #0FH
	movc a, @a+dptr
	anl a, #0x7f ; Turn on decimal point
	mov HEX3, a
	
	mov a, bcd+1
	anl a, #0FH
	movc a, @a+dptr
	mov HEX2, a

	mov a, bcd+0
	swap a
	anl a, #0FH
	movc a, @a+dptr
	mov HEX1, a
	
	mov a, bcd+0
	anl a, #0FH
	movc a, @a+dptr
	mov HEX0, a
	
	ret

Display_Voltage_LCD:
	Set_Cursor(2,1)
	mov a, #'V'
	lcall ?WriteData
	mov a, #'='
	lcall ?WriteData

	mov a, bcd+1
	swap a
	anl a, #0FH
	orl a, #'0'
	lcall ?WriteData
	
	mov a, #'.'
	lcall ?WriteData
	
	mov a, bcd+1
	anl a, #0FH
	orl a, #'0'
	lcall ?WriteData

	mov a, bcd+0
	swap a
	anl a, #0FH
	orl a, #'0'
	lcall ?WriteData
	
	mov a, bcd+0
	anl a, #0FH
	orl a, #'0'
	lcall ?WriteData
	
	ret
	
Display_Voltage_Serial:
	mov a, #'V'
	lcall putchar
	mov a, #'='
	lcall putchar

	mov a, bcd+1
	swap a
	anl a, #0FH
	orl a, #'0'
	lcall putchar
	
	mov a, #'.'
	lcall putchar
	
	mov a, bcd+1
	anl a, #0FH
	orl a, #'0'
	lcall putchar

	mov a, bcd+0
	swap a
	anl a, #0FH
	orl a, #'0'
	lcall putchar
	
	mov a, bcd+0
	anl a, #0FH
	orl a, #'0'
	lcall putchar

	mov a, #'\r'
	lcall putchar
	mov a, #'\n'
	lcall putchar
	
	ret

Initial_Message:  db 'Voltmeter test', 0

mycode:
	mov SP, #0x7F
	clr a
	mov LEDRA, a
	mov LEDRB, a
	
	lcall InitSerialPort
    lcall Timer2_Init
	
	; COnfigure the pins connected to the LCD as outputs
	mov P0MOD, #10101010b ; P0.1, P0.3, P0.5, P0.7 are outputs.  ('1' makes the pin output)
    mov P1MOD, #10000010b ; P1.7 and P1.1 are outputs

    ; Initial PWM output
    mov P3MOD, #10000000b   ; P3.7

    mov ADC_C, #0x80 ; Reset ADC
	lcall Wait50ms

    clr a
    mov pwm_tick_counter, a
    mov pwm_on_ticks, a

    setb EA              ; Enable global interrupts
    
    ; Set initial 0% and apply
    mov pwm, #0
    lcall Update_PWM        

    ; lcall ELCD_4BIT ; Configure LCD in four bit mode
    ; ; ; For convenience a few handy macros are included in 'LCD_4bit_DE1Lite.inc':
	; Set_Cursor(1, 1)
    ; Send_Constant_String(#Initial_Message)
	
	mov dptr, #Initial_Message
	lcall SendString
	mov a, #'\r'
	lcall putchar
	mov a, #'\n'
	lcall putchar

    ; Test UART
    mov a, #'T'
    lcall putchar
    mov a, #'E'
    lcall putchar
    mov a, #'S'
    lcall putchar
    mov a, #'T'
    lcall putchar
    mov a, #'\r'
    lcall putchar
    mov a, #'\n'
    lcall putchar
    
    mov pwm, #0
    lcall Update_PWM
    
    mov current_time, #0
    mov fsm_state, #0

    mov soaktime, #60
    mov soaktmp, #150

    mov reflowtime, #45
    mov reflowtmp, #220

    lcall Wait50ms

forever:
    lcall Read_Temperature_Simple
    
    lcall FSM_Reflow

    lcall Wait50ms
	ljmp forever

; ----------------------------------------
; TEMPERATURE ROUTINES
; ----------------------------------------
Read_Temperature:    
    ; Load LM335 ADC
    mov ADC_C, #0x01
    lcall Wait5ms

	mov x+3, #0
	mov x+2, #0
	mov x+1, ADC_H
	mov x+0, ADC_L

    Load_y(VREF_VALUE)
    lcall mul32     ; x = VREF * ADCLM335

    ; Load Reference ADC 
    mov ADC_C, #0x00 
    lcall Wait5ms

    mov y+3, #0
	mov y+2, #0
	mov y+1, ADC_H
	mov y+0, ADC_L

    lcall div32
    ; x = (VREF(mV) * ADCLM335)/ADCREF = VLM335 (mV)

    Load_y(2730)
    lcall sub32 
    ; x = (VLM335 - 2730mV)

    Load_y(10)
    lcall div32
    ; x = (VLM335 -2730mV)/(10mV/C)

    mov coldj_tmp+3, x+3
    mov coldj_tmp+2, x+2
    mov coldj_tmp+1, x+1
    mov coldj_tmp+0, x+0

    ; coldj_tmp = TC

    mov ADC_C, #0x02
    lcall Wait5ms

	mov x+3, #0
	mov x+2, #0
	mov x+1, ADC_H
	mov x+0, ADC_L

    Load_y(330) ; (4096mV)/(0.041mV) * (1/303)
    lcall mul32
    ; x = (4096mV/0.041mV)*(1/303)*ADCOp

    mov ADC_C, #0x00
    lcall Wait5ms

    mov y+3, #0
	mov y+2, #0
	mov y+1, ADC_H
	mov y+0, ADC_L
    lcall div32
    ; x = ((4096mV/0.041mV)*(1/303)*ADCOp)/ADCref

    ; x = TH

    mov y+3, coldj_tmp+3
	mov y+2, coldj_tmp+2
	mov y+1, coldj_tmp+1
	mov y+0, coldj_tmp+0
    ; y = TC

    lcall add32
    ; x = TH + TC

    Load_y(1000)
    lcall mul32
    
	lcall hex2bcd

    lcall Display_Temp_Serial ;sending this ts to the serial port

    lcall Wait50ms
	lcall Wait50ms
	lcall Wait50ms
	lcall Wait50ms
    ret

Read_Temperature_Simple:
    mov ADC_C, #0x02
    lcall Wait5ms
	
	; Load 32-bit 'x' with 12-bit adc result
	mov x+3, #0
	mov x+2, #0
	mov x+1, ADC_H
	mov x+0, ADC_L
	
	; Convert to voltage by multiplying by 5.000 and dividing by 4096
	Load_y(5000)
	lcall mul32
	Load_y(4096)
	lcall div32
	
    Load_y(1000) ; convert to microvolts
    lcall mul32
    Load_y(12300) ; 41 * 300
    lcall div32

    Load_y(22) ; add cold junction temperature
    lcall add32

    mov current_tmp, x+0

    Load_y(1000)
    lcall mul32

    lcall hex2bcd
    ; lcall Display_Temp_Serial
    lcall Display_Voltage_7seg
    ret


Display_Temp_Serial:
	; mov a, #'T'
	; lcall putchar
	; mov a, #'='
	; lcall putchar
	
	mov a, bcd+3
	swap a
	anl a, #0FH
	orl a, #'0'
	lcall putchar
	
	mov a, bcd+3
	anl a, #0FH
	orl a, #'0'
	lcall putchar

	mov a, bcd+2
	swap a
	anl a, #0FH
	orl a, #'0'
	lcall putchar
	
	mov a, bcd+2
	anl a, #0FH
	orl a, #'0'
	lcall putchar

	mov a, bcd+1
	swap a
	anl a, #0FH
	orl a, #'0'
	lcall putchar
	
	mov a, #'.'
	lcall putchar
	
	mov a, bcd+1
	anl a, #0FH
	orl a, #'0'
	lcall putchar

	mov a, bcd+0
	swap a
	anl a, #0FH
	orl a, #'0'
	lcall putchar
	
	mov a, bcd+0
	anl a, #0FH
	orl a, #'0'
	lcall putchar

	mov a, #'\r'
	lcall putchar
	mov a, #'\n'
	lcall putchar
	
	ret

Wait5ms:
    push acc
    mov R2, #25
Wait5ms_L1:
    lcall Wait200us
    djnz R2, Wait5ms_L1
    pop acc
    ret

Wait200us:
    push acc
    mov R3, #250
Wait200us_L1:
    nop
    nop
    djnz R3, Wait200us_L1
    pop acc
    ret

; ====================================================================
; FSM
; ====================================================================
FSM_STATE_MSG:
    DB 'FSM State: ', 0


FSM_Reflow:
    push ACC
    push PSW

    mov a, fsm_state
FSM_State0:
    cjne a, #0, FSM_State1
    mov pwm, #0
    lcall Update_PWM

    jb START_BUTTON, FSM_State0_Done
    lcall Wait50ms
    jb START_BUTTON, FSM_State0_Done
    jnb START_BUTTON, $
    
    mov dptr, #FSM_STATE_MSG
    lcall SendString
    mov a, #'1'
    lcall putchar
    mov a, #'\r'
    lcall putchar
    mov a, #'\n'
    lcall putchar

    mov fsm_state, #1
    lcall buzzer_subroutine

    ; mov a, temp
    ; mov temp_state_start, a
    ; mov temp_max_state, a
    ; mov temp_previous, a
    ; mov undertemp_checked, #0
FSM_State0_Done:
    ljmp FSM_Done

FSM_State1:
    cjne a, #1, FSM_State2
    mov pwm, #100
    lcall Update_PWM

    mov current_time, #0
    
    mov a, #soaktmp
    clr c
    subb a, current_tmp

    jnc FSM_State1_Done

    mov dptr, #FSM_STATE_MSG
    lcall SendString
    mov a, #'2'
    lcall putchar
    mov a, #'\r'
    lcall putchar
    mov a, #'\n'
    lcall putchar

    mov fsm_state, #2
	lcall buzzer_subroutine

    ; jc Check_Temp_Drop
    ; mov a, temp
    ; mov temp_max_state, a
; Check_Temp_Drop:
;     mov a, temp_max_state
;     clr c
;     subb a, temp
;     clr c
;     subb a, #TEMP_DROP_THRESHOLD
;     jc Check_Door_Open
;     mov error_code, #ERR_TEMP_DROP
;     ljmp Handle_Error
    
; Check_Door_Open:
;     mov a, temp_previous
;     clr c
;     subb a, temp
;     clr c
;     subb a, #20
;     jc Check_UnderTemp
;     mov error_code, #ERR_DOOR_OPEN
;     ljmp Handle_Error
    
; Check_UnderTemp:
;     mov a, undertemp_checked
;     jnz Check_Soak_Temp
;     mov a, state_timer
;     cjne a, #1, Check_Soak_Temp
;     mov undertemp_checked, #1
;     mov a, temp
;     clr c
;     subb a, #50
;     jnc Check_Soak_Temp
;     mov error_code, #ERR_UNDERTEMP
;     ljmp Handle_Error
    
; Check_Soak_Temp:
;     mov a, tempsoak
;     clr c
;     subb a, temp
;     jnc FSM_State1_Check_Timeout
;     mov FSM_state, #2
;     mov sec, #0
;     mov state_timer, #0
;     ljmp FSM_State1_Done
    
; FSM_State1_Check_Timeout:
;     mov a, state_timer
;     cjne a, #120, FSM_State1_Done
;     mov error_code, #ERR_TIMEOUT
;     ljmp Handle_Error
FSM_State1_Done:
    ljmp FSM_Done

FSM_State2:

    cjne a, #2, FSM_State3
    mov pwm, #20
    lcall Update_PWM

    mov a, soaktime
    clr c

    subb a, current_time
    jnc FSM_State2_Done

    mov dptr, #FSM_STATE_MSG
    lcall SendString
    mov a, #'3'
    lcall putchar
    mov a, #'\r'
    lcall putchar
    mov a, #'\n'
    lcall putchar

    mov FSM_state, #3
	lcall buzzer_subroutine

    ; mov sec, #0
    ; mov state_timer, #0
    ; mov a, temp
    ; mov temp_max_state, a
FSM_State2_Done:
    ljmp FSM_Done

FSM_State3:
	
    cjne a, #3, FSM_State4
    mov pwm, #100
    lcall Update_PWM

    mov current_time, #0
    
    mov a, reflowtmp
    clr c
    subb a, current_tmp

    jnc FSM_State3_Done

    mov dptr, #FSM_STATE_MSG
    lcall SendString
    mov a, #'4'
    lcall putchar
    mov a, #'\r'
    lcall putchar
    mov a, #'\n'
    lcall putchar

    mov fsm_state, #4
	lcall buzzer_subroutine

;     jc FSM_State3_Check_Reflow
;     mov a, temp
;     mov temp_max_state, a
    
; FSM_State3_Check_Reflow:
;     mov a, tempreflow
;     clr c
;     subb a, temp
;     jnc FSM_State3_Check_Timeout
;     mov FSM_state, #4
;     mov sec, #0
;     mov state_timer, #0
;     ljmp FSM_State3_Done
    
; FSM_State3_Check_Timeout:
;     mov a, state_timer
;     cjne a, #90, FSM_State3_Done
;     mov error_code, #ERR_TIMEOUT
;     ljmp Handle_Error
FSM_State3_Done:
    ljmp FSM_Done

FSM_State4:
    cjne a, #4, FSM_State5
    mov pwm, #20             ; ? Now actually 20% with real PWM!
    lcall Update_PWM
    
    mov a, reflowtime
    clr c
    subb a, current_time

    jnc FSM_State4_Done

    mov dptr, #FSM_STATE_MSG
    lcall SendString
    mov a, #'5'
    lcall putchar
    mov a, #'\r'
    lcall putchar
    mov a, #'\n'
    lcall putchar

    mov fsm_state, #5
	lcall buzzer_subroutine


; Temp_Too_High:
;     mov error_code, #ERR_OVERTEMP
;     ljmp Handle_Error
    
; Check_Reflow_Time:
;     mov a, timereflow
;     clr c
;     subb a, sec
;     jnc FSM_State4_Done
;     mov FSM_state, #5
;     mov sec, #0
FSM_State4_Done:
    ljmp FSM_Done

FSM_State5:
    cjne a, #5, FSM_Done
    mov pwm, #0
    lcall Update_PWM

    mov a, current_tmp
    clr c
    subb a, #60
    jnc FSM_State5_Done

    mov dptr, #FSM_STATE_MSG
    lcall SendString
    mov a, #'0'
    lcall putchar
    mov a, #'\r'
    lcall putchar
    mov a, #'\n'
    lcall putchar

    mov FSM_state, #0
   	lcall buzzer_subroutine
	lcall buzzer_subroutine
	lcall buzzer_subroutine
	lcall buzzer_subroutine
	lcall buzzer_subroutine
	
FSM_State5_Done:
FSM_Done:
    ; mov a, temp
    ; mov temp_previous, a

    pop PSW
    pop ACC
    ret

buzzer_subroutine:

	setb ET0
	setb TR0	
	
	lcall Wait50ms
	lcall Wait50ms
	lcall Wait50ms
	lcall Wait50ms
	lcall Wait50ms
	lcall Wait50ms
	lcall Wait50ms
	lcall Wait50ms
	lcall Wait50ms
	lcall Wait50ms
	lcall Wait50ms
	lcall Wait50ms
	lcall Wait50ms
	lcall Wait50ms
	lcall Wait50ms
	lcall Wait50ms
	lcall Wait50ms
	lcall Wait50ms
	lcall Wait50ms
	lcall Wait50ms	
	
	clr ET0
	clr TR0
	
	ret

end
