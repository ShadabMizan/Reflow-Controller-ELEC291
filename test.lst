0000              1   ;This program receives keyboard input from the PS/2 port on the DE1-SOC
0000              2   ;----------------------------------------;
0000              3   ;                  Workflow:             ;
0000              4   ;         1. Initialize PS/2 pins        ;
0000              5   ;         2. Wait for falling edge       ;
0000              6   ;                of PS/2 clock           ;
0000              7   ;         3. Read PS/2 data stream       ;
0000              8   ;----------------------------------------;
0000              9   ;|Start Bit|SCANCODE|Parity Bit|Stop Bit|;
0000             10   ;----------------------------------------;
0000             11   ;           ^^^^^^^^                     ;
0000             12   ;           8-bit val                    ;
0000             13   ;         4. If scancode == 0xF0,        ;
0000             14   ;            interpret as key release    ;
0000             15   ;         5. Else, interpret as          ;
0000             16   ;            key press                   ;
0000             17   ;----------------------------------------;
                 19   $LIST
0000             21   BAUD           equ 115200
0000             22   TIMER_2_RELOAD equ (0x10000-(CLK/(32*BAUD)))
0000             23   CLK EQU 33333333
0000             24   TIMER_10ms EQU (65536-(CLK/(12*100)))
0000             25   PS2_DAT EQU P3.3
0000             26   TRANSMIT_MODE EQU P0.0
0000             27   TRANSMIT_PARAM EQU P0.2
0000             28   TRANSMIT_SET EQU P0.4
0000             29   
0000             30   BIT1 EQU P1.3
0000             31   BIT2 EQU P1.5
0000             32   BIT3 EQU P1.7
0000             33   BIT4 EQU P2.1
0000             34   BIT5 EQU P2.3
0000             35   BIT6 EQU P2.5
0000             36   BIT7 EQU P2.7
0000             37   BIT8 EQU P3.1
0000             38   
0000             39   RELEASE_FLAG BIT 20h.0
0000             40   SET_FLAG BIT 20h.1
0000             41   MODE BIT 20h.2 ;0=Soak, 1=Reflow
0000             42   PARAM BIT 20h.3;0=Temp, 1=Time
0000             43   INVALID BIT 20h.4 ;Encountered invalid input
0000             44   AWAIT BIT 20h.5
0000             45   INPUTTING BIT 20h.6
0000             46   PROMPT_PENDING BIT 20h.7 ; Flag to show prompt on next Enter
0000             47   GET_PARAM BIT 21h.0 ; Flag to show parameter value on Enter
0000             48   
0000             49   ; Data storage for parameters
0030             50   dseg at 30h
0030             51   SoakTemp:    ds 1  ; Soak temperature parameter
0031             52   SoakTime:    ds 1  ; Soak time parameter
0032             53   ReflowTemp:  ds 1  ; Reflow temperature parameter
0033             54   ReflowTime:  ds 1  ; Reflow time parameter
0034             55   InputBuffer: ds 3  ; 3-byte buffer for building the number (max 3 digits for 255)
0037             56   
0000             57   cseg
0000             58       org 0000h       
0000 02050F      59       ljmp MainProgram
0003             60       
0003             61       ;Interrupt on keypress at address 0003h
0003             62       org 0003h
0003 020396      63       ljmp PS2_Interrupt
0006             64            
0030             65   org 0030h
0030             66   ASCII_TABLE:
0030 00000000    67            DB 0, 0, 0, 0, 0, 0, 0, 0        ; 00-07
     00000000
0038 00000000    68            DB 0, 0, 0, 0, 0, 0, '`', 0      ; 08-0F
     00006000
0040 00000000    69            DB 0, 0, 0, 0, 0, 'q', '1', 0    ; 10-17
     00713100
0048 00007A73    70            DB 0, 0, 'z', 's', 'a', 'w', '2', 0  ; 18-1F
     61773200
0050 00637864    71            DB 0, 'c', 'x', 'd', 'e', '4', '3', 0  ; 20-27
     65343300
0058 00207666    72            DB 0, ' ', 'v', 'f', 't', 'r', '5', 0  ; 28-2F
     74723500
0060 006E6268    73            DB 0, 'n', 'b', 'h', 'g', 'y', '6', 0  ; 30-37
     67793600
0068 00006D6A    74            DB 0, 0, 'm', 'j', 'u', '7', '8', 0    ; 38-3F
     75373800
0070 002C6B69    75            DB 0, ',', 'k', 'i', 'o', '0', '9', 0  ; 40-47
     6F303900
0078 002E2F6C    76            DB 0, '.', '/', 'l', ';', 'p', '-', 0  ; 48-4F
     3B702D00
0080 00002700    77            DB 0, 0, 27h, 0, '[', '=', 0, 0        ; 50-57 (27h = apostrophe)
     5B3D0000
0088 00000A5D    78            DB 0, 0, 0Ah, ']', 0, 5Ch, 0, 0          ; 58-5F (0Ah = decimal 10 = Enter/newline key)
     005C0000
0090 00000000    79            DB 0, 0, 0, 0, 0, 0, 0, 0              ; 60-67
     00000000
0098 00000000    80            DB 0, 0, 0, 0, 0, 0, 0, 0              ; 68-6F
     00000000
00A0 00000000    81            DB 0, 0, 0, 0, 0, 0, 0, 0              ; 70-77
     00000000
00A8 00000000    82            DB 0, 0, 0, 0, 0, 0, 0, 0              ; 78-7F
     00000000
00B0             83   
00B0             84   ; Look-up table for 7-seg displays
00B0             85   SEG7_LUT:
00B0 C0F9A4B0    86       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
00B5 9282F880    87       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
00BA 8883C6A1    88       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
00C0 5741524E    89   WarningStr: db 'WARNING: CHANGES NOT APPLIED. TO ENTER SET MODE, BEGIN COMMAND WITH "C".\n\r>',0
     494E473A
     20434841
     4E474553
     204E4F54
     20415050
     4C494544
     2E20544F
     20454E54
     45522053
     4554204D
     4F44452C
     20424547
     494E2043
     4F4D4D41
     4E442057
     49544820
     2243222E
     0A0D3E00
010C 4552524F    90   ErrorStr:   db 'ERROR: INVALID COMMAND.\n\r>', 0
     523A2049
     4E56414C
     49442043
     4F4D4D41
     4E442E0A
     0D3E00
0127 0A0D4552    91   InputErrorStr: db '\n\rERROR: INVALID INPUT. ENTER A NUMBER 0-255.\n\r>', 0
     524F523A
     20494E56
     414C4944
     20494E50
     55542E20
     454E5445
     52204120
     4E554D42
     45522030
     2D323535
     2E0A0D3E
     00
0158 50617261    92   SoakTempStr:db 'Param SOAK TEMP? =',0
     6D20534F
     414B2054
     454D503F
     203D00
016B 50617261    93   SoakTimeStr:db 'Param SOAK TIME? =',0
     6D20534F
     414B2054
     494D453F
     203D00
017E 50617261    94   ReflTempStr:db 'Param REFLOW TEMP? =',0
     6D205245
     464C4F57
     2054454D
     503F203D
     00
0193 50617261    95   ReflTimeStr:db 'Param REFLOW TIME? =',0
     6D205245
     464C4F57
     2054494D
     453F203D
     00
01A8 0A0D5061    96   SavedStr:   db '\n\rParameter saved.\n\r>',0
     72616D65
     74657220
     73617665
     642E0A0D
     3E00
01BE             97   
01BE             98   InitSerialPort:
01BE 75CBFF      99            mov RCAP2H, #HIGH(TIMER_2_RELOAD);
01C1 75CAF7     100            mov RCAP2L, #LOW(TIMER_2_RELOAD);
01C4 75C834     101            mov T2CON, #0x34 ; // #00110100B
01C7 759852     102            mov SCON, #0x52 ; // Serial port in mode 1, ren, txrdy, rxempty
01CA 22         103            ret
01CB            104   
01CB            105   putchar:
01CB 3099FD     106       JNB TI, putchar
01CE C299       107       CLR TI
01D0 F599       108       MOV SBUF, a
01D2 22         109       RET
01D3            110       
01D3            111   SendString:
01D3 E4         112       CLR A
01D4 93         113       MOVC A, @A+DPTR
01D5 6006       114       JZ SSDone
01D7 1201CB     115       LCALL putchar
01DA A3         116       INC DPTR
01DB 80F6       117       SJMP SendString
01DD            118   SSDone:
01DD 22         119       ret
01DE            120   
01DE            121   Initialize_PS2:
01DE            122            ;Configure serial protocol for PS/2
01DE D2B3       123            setb PS2_DAT
01E0 D288       124            setb IT0         ;Setting IT0 makes external interrupts edge-triggered rather than state-triggered
01E2 D2A8       125            setb EX0         ;Enable external interrupts
01E4 D2AF       126            setb EA          ;Enable interrupts
01E6 7800       127            mov R0, #0               ;Stores what bit we're reading
01E8 7900       128            mov R1, #0               ;Stores values of data
01EA C200       129            clr RELEASE_FLAG
01EC C201       130            clr SET_FLAG
01EE C206       131            clr INPUTTING
01F0 C207       132            clr PROMPT_PENDING
01F2 C208       133            clr GET_PARAM
01F4            134            ; Initialize input buffer
01F4 753400     135            mov InputBuffer, #0
01F7 753500     136            mov InputBuffer+1, #0
01FA 753600     137            mov InputBuffer+2, #0
01FD 22         138            ret
01FE            139            
01FE            140   Scancode_To_ASCII:
01FE 900030     141            mov DPTR, #ASCII_TABLE
0201 93         142            movc A, @A+DPTR
0202 22         143            ret
0203            144   
0203            145   Update_HEX_Display:
0203            146            ; Display "C" (0xC6) for temperature or "S" (0x92) for time
0203 200304     147            jb PARAM, Show_S
0206            148            ; Show "C" for temperature
0206 7591C6     149            mov HEX0, #0xC6
0209 22         150            ret
020A            151   Show_S:
020A            152            ; Show "S" for time
020A 759192     153            mov HEX0, #0x92
020D 22         154            ret
020E            155   
020E            156   ; Update output pins with current state
020E            157   UpdateOutputs:
020E            158            ; Update TRANSMIT_MODE (P0.0) with MODE bit
020E 200204     159            jb MODE, SetMode1
0211 C280       160            clr TRANSMIT_MODE
0213 8002       161            sjmp DoneMode
0215            162   SetMode1:
0215 D280       163            setb TRANSMIT_MODE
0217            164   DoneMode:
0217            165            
0217            166            ; Update TRANSMIT_PARAM (P0.2) with PARAM bit
0217 200304     167            jb PARAM, SetParam1
021A C282       168            clr TRANSMIT_PARAM
021C 8002       169            sjmp DoneParam
021E            170   SetParam1:
021E D282       171            setb TRANSMIT_PARAM
0220            172   DoneParam:
0220            173            
0220            174            ; Update TRANSMIT_SET (P0.4) with SET_FLAG bit
0220 200104     175            jb SET_FLAG, SetFlag1
0223 C284       176            clr TRANSMIT_SET
0225 8002       177            sjmp DoneSet
0227            178   SetFlag1:
0227 D284       179            setb TRANSMIT_SET
0229            180   DoneSet:
0229            181            
0229            182            ; Get current parameter value
0229 12033F     183            lcall GetCurrentParam  ; Returns value in A
022C FA         184            mov R2, A             ; Save in R2
022D            185            
022D            186            ; Output the 8-bit value to BIT1-BIT8
022D            187            ; Bit 0 -> BIT1 (P1.3)
022D EA         188            mov A, R2
022E 20E004     189            jb ACC.0, SetBit1
0231 C293       190            clr BIT1
0233 8002       191            sjmp DoneBit1
0235            192   SetBit1:
0235 D293       193            setb BIT1
0237            194   DoneBit1:
0237            195            
0237            196            ; Bit 1 -> BIT2 (P1.5)
0237 EA         197            mov A, R2
0238 20E104     198            jb ACC.1, SetBit2
023B C295       199            clr BIT2
023D 8002       200            sjmp DoneBit2
023F            201   SetBit2:
023F D295       202            setb BIT2
0241            203   DoneBit2:
0241            204            
0241            205            ; Bit 2 -> BIT3 (P1.7)
0241 EA         206            mov A, R2
0242 20E204     207            jb ACC.2, SetBit3
0245 C297       208            clr BIT3
0247 8002       209            sjmp DoneBit3
0249            210   SetBit3:
0249 D297       211            setb BIT3
024B            212   DoneBit3:
024B            213            
024B            214            ; Bit 3 -> BIT4 (P2.1)
024B EA         215            mov A, R2
024C 20E304     216            jb ACC.3, SetBit4
024F C2A1       217            clr BIT4
0251 8002       218            sjmp DoneBit4
0253            219   SetBit4:
0253 D2A1       220            setb BIT4
0255            221   DoneBit4:
0255            222            
0255            223            ; Bit 4 -> BIT5 (P2.3)
0255 EA         224            mov A, R2
0256 20E404     225            jb ACC.4, SetBit5
0259 C2A3       226            clr BIT5
025B 8002       227            sjmp DoneBit5
025D            228   SetBit5:
025D D2A3       229            setb BIT5
025F            230   DoneBit5:
025F            231            
025F            232            ; Bit 5 -> BIT6 (P2.5)
025F EA         233            mov A, R2
0260 20E504     234            jb ACC.5, SetBit6
0263 C2A5       235            clr BIT6
0265 8002       236            sjmp DoneBit6
0267            237   SetBit6:
0267 D2A5       238            setb BIT6
0269            239   DoneBit6:
0269            240            
0269            241            ; Bit 6 -> BIT7 (P2.7)
0269 EA         242            mov A, R2
026A 20E604     243            jb ACC.6, SetBit7
026D C2A7       244            clr BIT7
026F 8002       245            sjmp DoneBit7
0271            246   SetBit7:
0271 D2A7       247            setb BIT7
0273            248   DoneBit7:
0273            249            
0273            250            ; Bit 7 -> BIT8 (P3.1)
0273 EA         251            mov A, R2
0274 20E704     252            jb ACC.7, SetBit8
0277 C2B1       253            clr BIT8
0279 8002       254            sjmp DoneBit8
027B            255   SetBit8:
027B D2B1       256            setb BIT8
027D            257   DoneBit8:
027D            258            
027D 22         259            ret
027E            260   
027E            261   ; Clear input buffer
027E            262   ClearInputBuffer:
027E 753400     263            mov InputBuffer, #0
0281 753500     264            mov InputBuffer+1, #0
0284 753600     265            mov InputBuffer+2, #0
0287 22         266            ret
0288            267   
0288            268   ; Add ASCII character to input buffer
0288            269   ; Input: A contains ASCII character
0288            270   ; Just stores it in the buffer, no validation
0288            271   AddToBuffer:
0288            272            ; Check if buffer already has 3 characters
0288 AA36       273            mov R2, InputBuffer+2
028A BA0013     274            cjne R2, #0, BufferFull
028D AA35       275            mov R2, InputBuffer+1
028F BA000B     276            cjne R2, #0, AddThird
0292 AA34       277            mov R2, InputBuffer
0294 BA0003     278            cjne R2, #0, AddSecond
0297            279            ; First character
0297 F534       280            mov InputBuffer, A
0299 22         281            ret
029A            282   AddSecond:
029A            283            ; Second character  
029A F535       284            mov InputBuffer+1, A
029C 22         285            ret
029D            286   AddThird:
029D            287            ; Third character
029D F536       288            mov InputBuffer+2, A
029F 22         289            ret
02A0            290   BufferFull:
02A0            291            ; Already have 3 characters, can't add more (will check on Enter)
02A0 22         292            ret
02A1            293   
02A1            294   ; Validate and convert input buffer to number
02A1            295   ; Returns: A = converted number (0-255), CY = 1 if error
02A1            296   ValidateAndConvert:
02A1            297            ; Check if buffer is empty
02A1 E534       298            mov A, InputBuffer
02A3 6053       299            jz EmptyInput
02A5            300            
02A5            301            ; Check if first character is a digit
02A5 E534       302            mov A, InputBuffer
02A7 1202FA     303            lcall CheckDigit
02AA 404C       304            jc ValidationError
02AC FC         305            mov R4, A              ; Save first digit value in R4
02AD            306            
02AD            307            ; Check if there's a second character
02AD E535       308            mov A, InputBuffer+1
02AF 6044       309            jz SingleDigit        ; Only one digit
02B1            310            
02B1            311            ; Check if second character is a digit
02B1 1202FA     312            lcall CheckDigit
02B4 4042       313            jc ValidationError
02B6 FD         314            mov R5, A             ; Save second digit value in R5
02B7            315            
02B7            316            ; Check if there's a third character
02B7 E536       317            mov A, InputBuffer+2
02B9 6030       318            jz TwoDigits          ; Only two digits
02BB            319            
02BB            320            ; Check if third character is a digit
02BB 1202FA     321            lcall CheckDigit
02BE 4038       322            jc ValidationError
02C0 FE         323            mov R6, A             ; Save third digit value in R6
02C1            324            
02C1            325            ; Calculate: first_digit * 100 + second_digit * 10 + third_digit
02C1 EC         326            mov A, R4             ; Get first digit
02C2 75F064     327            mov B, #100
02C5 A4         328            mul AB                ; A = first_digit * 100, B = overflow
02C6            329            ; Check if multiplication overflowed (B should be 0 unless first_digit >= 3)
02C6 FF         330            mov R7, A             ; Save result (first * 100)
02C7 E5F0       331            mov A, B
02C9 700F       332            jnz CheckValid3Digit  ; If B != 0, need to validate carefully
02CB            333            
02CB            334   Add2ndAnd3rdDigits:
02CB            335            ; Add second_digit * 10
02CB ED         336            mov A, R5
02CC 75F00A     337            mov B, #10
02CF A4         338            mul AB
02D0 2F         339            add A, R7             ; Add to running total
02D1 4025       340            jc ValidationError    ; Overflow
02D3 FF         341            mov R7, A
02D4            342            
02D4            343            ; Add third digit
02D4 EF         344            mov A, R7
02D5 2E         345            add A, R6
02D6 4020       346            jc ValidationError    ; Overflow
02D8            347            
02D8            348            ; Final result in A
02D8 C3         349            clr C
02D9 22         350            ret
02DA            351   
02DA            352   CheckValid3Digit:
02DA            353            ; First digit is >= 3, could be 200-299, need to validate
02DA            354            ; Only 200-255 are valid
02DA EC         355            mov A, R4
02DB B4021A     356            cjne A, #2, ValidationError  ; If first digit != 2, it's > 255
02DE            357            ; First digit is 2, check if 2XX <= 255
02DE            358            ; This means second_digit * 10 + third_digit <= 55
02DE ED         359            mov A, R5
02DF 75F00A     360            mov B, #10
02E2 A4         361            mul AB
02E3 2E         362            add A, R6
02E4            363            ; A now has the last two digits as a number
02E4 C3         364            clr C
02E5 9438       365            subb A, #56           ; Check if > 55
02E7 500F       366            jnc ValidationError   ; If >= 56, then 2XX > 255
02E9            367            ; Valid! Calculate actual value
02E9 80E0       368            sjmp Add2ndAnd3rdDigits
02EB            369   
02EB            370   TwoDigits:
02EB            371            ; Calculate: first_digit * 10 + second_digit
02EB EC         372            mov A, R4             ; Get first digit
02EC 75F00A     373            mov B, #10
02EF A4         374            mul AB                ; A = first_digit * 10
02F0 2D         375            add A, R5             ; Add second digit
02F1 4005       376            jc ValidationError    ; Overflow (shouldn't happen with 2 digits)
02F3 C3         377            clr C
02F4 22         378            ret
02F5            379   
02F5            380   SingleDigit:
02F5 EC         381            mov A, R4             ; Single digit value
02F6 C3         382            clr C
02F7 22         383            ret
02F8            384   
02F8            385   EmptyInput:
02F8            386   ValidationError:
02F8 D3         387            setb C
02F9 22         388            ret
02FA            389   
02FA            390   ; Check if ASCII character in A is a digit ('0'-'9')
02FA            391   ; Returns: A = numeric value (0-9), CY = 1 if not a digit
02FA            392   CheckDigit:
02FA C3         393            clr C
02FB 9430       394            subb A, #'0'
02FD 400B       395            jc NotDigit           ; Less than '0'
02FF            396            ; A now contains value 0-? 
02FF F5F0       397            mov B, A
0301 C3         398            clr C
0302 940A       399            subb A, #10           ; Check if >= 10
0304 5004       400            jnc NotDigit          ; If A >= 10, not a digit
0306 E5F0       401            mov A, B              ; Restore numeric value (0-9)
0308 C3         402            clr C
0309 22         403            ret
030A            404   NotDigit:
030A D3         405            setb C
030B 22         406            ret
030C            407   
030C            408   ; Display number in A as decimal ASCII
030C            409   ; Input: A = number (0-255)
030C            410   DisplayNumber:
030C 75F064     411            mov B, #100
030F 84         412            div AB                ; A = hundreds, B = remainder
0310 AAF0       413            mov R2, B             ; Save remainder
0312 F5F0       414            mov B, A              ; Save hundreds digit
0314            415            
0314            416            ; Check if we need to display hundreds
0314 E5F0       417            mov A, B
0316 6005       418            jz SkipHundreds
0318 2430       419            add A, #'0'
031A 1201CB     420            lcall putchar
031D            421            
031D            422   SkipHundreds:
031D            423            ; Get tens digit
031D EA         424            mov A, R2             ; Get remainder
031E 75F00A     425            mov B, #10
0321 84         426            div AB                ; A = tens, B = ones
0322 ABF0       427            mov R3, B             ; Save ones digit
0324            428            
0324            429            ; Display tens (if hundreds was shown, or if tens > 0)
0324 F5F0       430            mov B, A              ; Save tens
0326 EA         431            mov A, R2
0327 7A64       432            mov R2, #100
0329 C3         433            clr C
032A 9A         434            subb A, R2
032B 5004       435            jnc ShowTens          ; If original remainder >= 100, show tens
032D E5F0       436            mov A, B
032F 6007       437            jz SkipTens           ; If no hundreds and tens = 0, skip
0331            438            
0331            439   ShowTens:
0331 E5F0       440            mov A, B
0333 2430       441            add A, #'0'
0335 1201CB     442            lcall putchar
0338            443            
0338            444   SkipTens:
0338            445            ; Always display ones digit
0338 EB         446            mov A, R3
0339 2430       447            add A, #'0'
033B 1201CB     448            lcall putchar
033E 22         449            ret
033F            450   
033F            451   ; Get the currently selected parameter value
033F            452   ; Returns: A = parameter value
033F            453   GetCurrentParam:
033F 200209     454            jb MODE, GetReflowParam
0342            455            ; MODE = 0: Soak
0342 200303     456            jb PARAM, GetSoakTime
0345 E530       457            mov A, SoakTemp
0347 22         458            ret
0348            459   GetSoakTime:
0348 E531       460            mov A, SoakTime
034A 22         461            ret
034B            462   GetReflowParam:
034B            463            ; MODE = 1: Reflow
034B 200303     464            jb PARAM, GetReflowTime
034E E532       465            mov A, ReflowTemp
0350 22         466            ret
0351            467   GetReflowTime:
0351 E533       468            mov A, ReflowTime
0353 22         469            ret
0354            470   
0354            471   ; Save the input buffer to the appropriate parameter variable
0354            472   SaveInputToParam:
0354            473            ; First validate and convert the input
0354 1202A1     474            lcall ValidateAndConvert
0357 4028       475            jc SaveError          ; If CY = 1, validation failed
0359            476            
0359            477            ; A contains the valid number (0-255)
0359 FA         478            mov R2, A             ; Save the value
035A            479            
035A 20020D     480            jb MODE, SaveReflowParam
035D            481            ; MODE = 0: Soak
035D 200305     482            jb PARAM, SaveSoakTime
0360            483            ; Save to SoakTemp
0360 EA         484            mov A, R2
0361 F530       485            mov SoakTemp, A
0363 8010       486            sjmp ParamSaved
0365            487   SaveSoakTime:
0365 EA         488            mov A, R2
0366 F531       489            mov SoakTime, A
0368 800B       490            sjmp ParamSaved
036A            491   SaveReflowParam:
036A            492            ; MODE = 1: Reflow
036A 200305     493            jb PARAM, SaveReflowTime
036D            494            ; Save to ReflowTemp
036D EA         495            mov A, R2
036E F532       496            mov ReflowTemp, A
0370 8003       497            sjmp ParamSaved
0372            498   SaveReflowTime:
0372 EA         499            mov A, R2
0373 F533       500            mov ReflowTime, A
0375            501   ParamSaved:
0375 9001A8     502            mov dptr, #SavedStr
0378 1201D3     503            lcall SendString
037B C206       504            clr INPUTTING
037D 12027E     505            lcall ClearInputBuffer
0380 22         506            ret
0381            507   
0381            508   SaveError:
0381            509            ; Check if empty or invalid
0381 E534       510            mov A, InputBuffer
0383 600A       511            jz EmptyError
0385            512            ; Invalid/overflow error
0385 900127     513            mov dptr, #InputErrorStr
0388 1201D3     514            lcall SendString
038B 12027E     515            lcall ClearInputBuffer
038E 22         516            ret
038F            517   EmptyError:
038F 900127     518            mov dptr, #InputErrorStr
0392 1201D3     519            lcall SendString
0395 22         520            ret
0396            521            
0396            522   PS2_Interrupt:
0396 C0E0       523            push ACC
0398 C0D0       524            push PSW
039A            525            
039A E8         526            mov A, R0
039B            527            ;If we're at the start of a frame, validate start bit before incrementing
039B B40004     528            cjne A, #0, NotAtStart
039E A2B3       529            mov C, PS2_DAT
03A0 4008       530            jc jump    ;If start bit is 1, wait for valid start (should be 0)
03A2            531            
03A2            532   NotAtStart:
03A2 08         533            inc R0
03A3 E8         534            mov A, R0
03A4            535            ;Ignore start bit
03A4 B40106     536            cjne A, #1, CheckData
03A7 02050A     537            ljmp PS2_Done
03AA            538            
03AA            539   jump:
03AA 02050A     540            ljmp PS2_Done
03AD            541            
03AD            542   CheckData:
03AD            543            ;Read data bits
03AD C3         544            clr C
03AE 940A       545            subb A, #10      ;Carry if A < 10 (bits 2-9)
03B0 5012       546            jnc CheckIfDoneJump
03B2 A2B3       547            mov C, PS2_DAT   ;Read data line
03B4 E9         548            mov A, R1
03B5 13         549            rrc A            ;Shift into R1
03B6 F9         550            mov R1, A
03B7 E8         551            mov A, R0
03B8 B409EF     552            cjne A, #9, jump
03BB E9         553            mov A, R1
03BC B4F008     554            cjne A, #0F0h, NotRelease
03BF D200       555            setb RELEASE_FLAG ;stop code
03C1 02050A     556            ljmp PS2_Done
03C4            557   CheckIfDoneJump:
03C4 0204F8     558            ljmp CheckIfDone
03C7            559   NotRelease:
03C7 200013     560            jb RELEASE_FLAG, ClearRelJump
03CA 1201FE     561            lcall Scancode_To_ASCII
03CD 60DB       562            jz jump
03CF F5E8       563            mov LEDRA, A  
03D1            564            
03D1            565            ; Check if we're in number input mode
03D1 300615     566            jnb INPUTTING, NotInputtingNum
03D4            567            ; We're inputting a number - just accumulate characters
03D4 B40A09     568            cjne A, #0Ah, JustAddChar
03D7            569            ; Enter key pressed - validate and save the value
03D7 120354     570            lcall SaveInputToParam
03DA 02050A     571            ljmp PS2_Done
03DD            572            
03DD            573   ClearRelJump:
03DD 0204F4     574            ljmp ClearRel
03E0            575   JustAddChar:
03E0            576            ; Just echo the character and add to buffer (no validation yet)
03E0 1201CB     577            lcall putchar
03E3 120288     578            lcall AddToBuffer
03E6 02050A     579            ljmp PS2_Done
03E9            580            
03E9            581   NotInputtingNum:
03E9            582            ; Check if we need to show a prompt (Enter pressed after 't' or 'x')
03E9 B40A1B     583            cjne A, #0Ah, NotEnterJump
03EC            584            ; Enter key pressed
03EC 30073E     585            jnb PROMPT_PENDING, CheckGetParam
03EF            586            ; We need to show the parameter prompt
03EF 740A       587            mov A, #0Ah    
03F1 1201CB     588            lcall putchar
03F4 740D       589            mov A, #'\r'   
03F6 1201CB     590            lcall putchar
03F9            591            ; Show the appropriate prompt based on MODE and PARAM
03F9 200216     592            jb MODE, ShowReflowPrompt
03FC 20030B     593            jb PARAM, ShowSoakTimePrompt
03FF 900158     594            mov dptr, #SoakTempStr
0402 1201D3     595            lcall SendString
0405 801C       596            sjmp StartInputMode
0407            597   NotEnterJump:
0407 0204A5     598            ljmp NotEnter
040A            599   ShowSoakTimePrompt:
040A 90016B     600            mov dptr, #SoakTimeStr
040D 1201D3     601            lcall SendString
0410 8011       602            sjmp StartInputMode
0412            603   ShowReflowPrompt:
0412 200308     604            jb PARAM, ShowReflowTimePrompt
0415 90017E     605            mov dptr, #ReflTempStr
0418 1201D3     606            lcall SendString
041B 8006       607            sjmp StartInputMode
041D            608   ShowReflowTimePrompt:
041D 900193     609            mov dptr, #ReflTimeStr
0420 1201D3     610            lcall SendString
0423            611   StartInputMode:
0423 D206       612            setb INPUTTING
0425 C207       613            clr PROMPT_PENDING
0427 12027E     614            lcall ClearInputBuffer
042A 02050A     615            ljmp PS2_Done
042D            616   
042D            617   CheckGetParam:
042D            618            ; Check if we need to display current parameter value
042D 30084B     619            jnb GET_PARAM, NormalEnter
0430            620            ; Display the current parameter
0430 740A       621            mov A, #0Ah    
0432 1201CB     622            lcall putchar
0435 740D       623            mov A, #'\r'   
0437 1201CB     624            lcall putchar
043A            625            ; Show parameter name
043A 200213     626            jb MODE, ShowReflowParamName
043D 200308     627            jb PARAM, ShowSoakTimeName
0440 900158     628            mov dptr, #SoakTempStr
0443 1201D3     629            lcall SendString
0446 8019       630            sjmp ShowParamValue
0448            631   ShowSoakTimeName:
0448 90016B     632            mov dptr, #SoakTimeStr
044B 1201D3     633            lcall SendString
044E 8011       634            sjmp ShowParamValue
0450            635   ShowReflowParamName:
0450 200308     636            jb PARAM, ShowReflowTimeName
0453 90017E     637            mov dptr, #ReflTempStr
0456 1201D3     638            lcall SendString
0459 8006       639            sjmp ShowParamValue
045B            640   ShowReflowTimeName:
045B 900193     641            mov dptr, #ReflTimeStr
045E 1201D3     642            lcall SendString
0461            643   ShowParamValue:
0461 12033F     644            lcall GetCurrentParam
0464 12030C     645            lcall DisplayNumber
0467 740A       646            mov A, #0Ah    
0469 1201CB     647            lcall putchar
046C 740D       648            mov A, #'\r'   
046E 1201CB     649            lcall putchar
0471 743E       650            mov A, #'>'
0473 1201CB     651            lcall putchar
0476 C208       652            clr GET_PARAM
0478 02050A     653            ljmp PS2_Done
047B            654            
047B            655   NormalEnter:
047B            656            ; Normal Enter handling (not after 't' or 'x')
047B 740A       657            mov A, #0Ah    
047D 1201CB     658            lcall putchar
0480 740D       659            mov A, #'\r'   
0482 1201CB     660            lcall putchar
0485 743E       661            mov A, #'>'     
0487 1201CB     662            lcall putchar
048A 200406     663            jb INVALID, Error
048D 30010D     664            jnb SET_FLAG, Warning
0490 02050A     665            ljmp PS2_Done
0493            666            
0493            667   Error:
0493 90010C     668            mov dptr, #ErrorStr
0496 1201D3     669            lcall SendString
0499 C204       670            clr INVALID
049B 806D       671            sjmp PS2_Done
049D            672            
049D            673   Warning:
049D 9000C0     674            mov dptr, #WarningStr
04A0 1201D3     675            lcall SendString
04A3 8065       676            sjmp PS2_Done
04A5            677            
04A5            678   NotEnter:
04A5 1201CB     679            lcall putchar
04A8 B47104     680            cjne A, #'q', NotQ
04AB C201       681            clr SET_FLAG
04AD 805B       682            sjmp PS2_Done
04AF            683   
04AF            684   NotQ:
04AF D205       685            setb AWAIT
04B1 200107     686            jb SET_FLAG, Setting
04B4 B46353     687            cjne A, #'c', PS2_Done
04B7 D201       688            setb SET_FLAG
04B9 804F       689            sjmp PS2_Done
04BB            690            
04BB            691   Setting:
04BB B47307     692            cjne A, #'s', CheckR
04BE C202       693            clr MODE
04C0 759502     694            mov LEDRB, #0b10  ; Show 10 for Soak
04C3 8045       695            sjmp PS2_Done
04C5            696            
04C5            697   CheckR:
04C5 B47209     698            cjne A, #'r', CheckT
04C8 D202       699            setb MODE
04CA 759501     700            mov LEDRB, #0b01  ; Show 01 for Reflow
04CD D205       701            setb AWAIT
04CF 8039       702            sjmp PS2_Done
04D1            703            
04D1            704   CheckT:
04D1 B47409     705            cjne A, #'t', CheckX
04D4 D203       706            setb PARAM
04D6 120203     707            lcall Update_HEX_Display
04D9 D207       708            setb PROMPT_PENDING   ; Will prompt on next Enter
04DB 802D       709            sjmp PS2_Done
04DD            710            
04DD            711   CheckX:
04DD B47809     712            cjne A, #'x', CheckG
04E0 C203       713            clr PARAM
04E2 120203     714            lcall Update_HEX_Display
04E5 D207       715            setb PROMPT_PENDING   ; Will prompt on next Enter
04E7 8021       716            sjmp PS2_Done
04E9            717   
04E9            718   CheckG:
04E9 B46704     719            cjne A, #'g', InvalidHandler
04EC D208       720            setb GET_PARAM        ; Will display current parameter on next Enter
04EE 801A       721            sjmp PS2_Done
04F0            722   
04F0            723   InvalidHandler:
04F0 D204       724            setb INVALID
04F2 8016       725            sjmp PS2_Done
04F4            726            
04F4            727   ClearRel:
04F4 C200       728            clr RELEASE_FLAG 
04F6 8012       729            sjmp PS2_Done
04F8            730   CheckIfDone:
04F8            731            ;Wait for Stop Bit
04F8 B40B08     732            cjne A, #11, CheckOverflow
04FB 8000       733            sjmp Reset
04FD            734            
04FD            735   Reset:
04FD            736            ;Resets so we're ready for next keypress
04FD 7800       737            mov R0, #0
04FF 7900       738            mov R1, #0
0501 8007       739            sjmp PS2_Done
0503            740   CheckOverflow:
0503            741            ;Prevents from going out of sync (this was a problem because we're not explicitly checking the parity bit)
0503 C3         742            clr C
0504 940C       743            subb A, #12
0506 4002       744            jc PS2_Done
0508 80F3       745            sjmp Reset
050A            746   PS2_Done:
050A D0D0       747            pop PSW
050C D0E0       748            pop ACC
050E 32         749            reti
050F            750   
050F            751   MainProgram:
050F 759AFF     752            mov P0MOD, #0b11111111
0512 759BFF     753            mov P1MOD, #0b11111111
0515 759CFF     754            mov P2MOD, #0b11111111
0518 759D01     755            mov P3MOD, #0b1
051B 75E800     756            mov LEDRA, #0X00
051E 759500     757            mov LEDRB, #0x00
0521 7591C6     758            mov HEX0, #0xC6  ; Initialize to "C" (temperature)
0524            759            
0524            760            ; Initialize parameters to default values
0524 753000     761            mov SoakTemp, #0
0527 753100     762            mov SoakTime, #0
052A 753200     763            mov ReflowTemp, #0
052D 753300     764            mov ReflowTime, #0
0530            765            
0530 75817F     766       mov sp, #0x7f
0533 740D       767       mov A, #'\r'
0535 1201DE     768       lcall Initialize_PS2
0538 1201BE     769       lcall InitSerialPort
053B 1201CB     770       lcall putchar
053E 740A       771            mov A, #'\n'
0540 1201CB     772            lcall putchar
0543 743E       773       mov A, #'>'
0545 1201CB     774       lcall putchar
0548            775       
0548            776       ; Initial output update
0548 12020E     777       lcall UpdateOutputs
054B            778       
054B            779   forever:
054B            780            ; Continuously update outputs
054B 12020E     781            lcall UpdateOutputs
054E 80FB       782            sjmp forever
0550            783            
0550            784   en
