0000              1   ;This program receives keyboard input from the PS/2 port on the DE1-SOC
0000              2   ;----------------------------------------;
0000              3   ;                  Workflow:             ;
0000              4   ;         1. Initialize PS/2 pins        ;
0000              5   ;         2. Wait for falling edge       ;
0000              6   ;                of PS/2 clock           ;
0000              7   ;         3. Read PS/2 data stream       ;
0000              8   ;----------------------------------------;
0000              9   ;|Start Bit|SCANCODE|Parity Bit|Stop Bit|;
0000             10   ;----------------------------------------;
0000             11   ;           ^^^^^^^^                     ;
0000             12   ;           8-bit val                    ;
0000             13   ;         4. If scancode == 0xF0,        ;
0000             14   ;            interpret as key release    ;
0000             15   ;         5. Else, interpret as          ;
0000             16   ;            key press                   ;
0000             17   ;----------------------------------------;
                 19   $LIST
0000             21   BAUD           equ 115200
0000             22   TIMER_2_RELOAD equ (0x10000-(CLK/(32*BAUD)))
0000             23   CLK EQU 33333333
0000             24   TIMER_10ms EQU (65536-(CLK/(12*100)))
0000             25   PS2_DAT EQU P3.3
0000             26   RELEASE_FLAG BIT 20h.0
0000             27   SET_FLAG BIT 20h.1
0000             28   MODE BIT 20h.2 ;0=Soak, 1=Reflow
0000             29   PARAM BIT 20h.3;0=Temp, 1=Time
0000             30   INVALID BIT 20h.4 ;Encountered invalid input
0000             31   AWAIT BIT 20h.5
0000             32   INPUTTING BIT 20h.6
0000             33   PROMPT_PENDING BIT 20h.7 ; Flag to show prompt on next Enter
0000             34   GET_PARAM BIT 21h.0 ; Flag to show parameter value on Enter
0000             35   
0000             36   ; Data storage for parameters
0030             37   dseg at 30h
0030             38   SoakTemp:    ds 1  ; Soak temperature parameter
0031             39   SoakTime:    ds 1  ; Soak time parameter
0032             40   ReflowTemp:  ds 1  ; Reflow temperature parameter
0033             41   ReflowTime:  ds 1  ; Reflow time parameter
0034             42   InputBuffer: ds 3  ; 3-byte buffer for building the number (max 3 digits for 255)
0037             43   
0000             44   cseg
0000             45       org 0000h       
0000 02049F      46       ljmp MainProgram
0003             47       
0003             48       ;Interrupt on keypress at address 0003h
0003             49       org 0003h
0003 020326      50       ljmp PS2_Interrupt
0006             51            
0030             52   org 0030h
0030             53   ASCII_TABLE:
0030 00000000    54            DB 0, 0, 0, 0, 0, 0, 0, 0        ; 00-07
     00000000
0038 00000000    55            DB 0, 0, 0, 0, 0, 0, '`', 0      ; 08-0F
     00006000
0040 00000000    56            DB 0, 0, 0, 0, 0, 'q', '1', 0    ; 10-17
     00713100
0048 00007A73    57            DB 0, 0, 'z', 's', 'a', 'w', '2', 0  ; 18-1F
     61773200
0050 00637864    58            DB 0, 'c', 'x', 'd', 'e', '4', '3', 0  ; 20-27
     65343300
0058 00207666    59            DB 0, ' ', 'v', 'f', 't', 'r', '5', 0  ; 28-2F
     74723500
0060 006E6268    60            DB 0, 'n', 'b', 'h', 'g', 'y', '6', 0  ; 30-37
     67793600
0068 00006D6A    61            DB 0, 0, 'm', 'j', 'u', '7', '8', 0    ; 38-3F
     75373800
0070 002C6B69    62            DB 0, ',', 'k', 'i', 'o', '0', '9', 0  ; 40-47
     6F303900
0078 002E2F6C    63            DB 0, '.', '/', 'l', ';', 'p', '-', 0  ; 48-4F
     3B702D00
0080 00002700    64            DB 0, 0, 27h, 0, '[', '=', 0, 0        ; 50-57 (27h = apostrophe)
     5B3D0000
0088 00000A5D    65            DB 0, 0, 0Ah, ']', 0, 5Ch, 0, 0          ; 58-5F (0Ah = decimal 10 = Enter/newline key)
     005C0000
0090 00000000    66            DB 0, 0, 0, 0, 0, 0, 0, 0              ; 60-67
     00000000
0098 00000000    67            DB 0, 0, 0, 0, 0, 0, 0, 0              ; 68-6F
     00000000
00A0 00000000    68            DB 0, 0, 0, 0, 0, 0, 0, 0              ; 70-77
     00000000
00A8 00000000    69            DB 0, 0, 0, 0, 0, 0, 0, 0              ; 78-7F
     00000000
00B0             70   
00B0             71   ; Look-up table for 7-seg displays
00B0             72   SEG7_LUT:
00B0 C0F9A4B0    73       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
00B5 9282F880    74       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
00BA 8883C6A1    75       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
00C0 5741524E    76   WarningStr: db 'WARNING: CHANGES NOT APPLIED. TO ENTER SET MODE, BEGIN COMMAND WITH "C".\n\r>',0
     494E473A
     20434841
     4E474553
     204E4F54
     20415050
     4C494544
     2E20544F
     20454E54
     45522053
     4554204D
     4F44452C
     20424547
     494E2043
     4F4D4D41
     4E442057
     49544820
     2243222E
     0A0D3E00
010C 4552524F    77   ErrorStr:   db 'ERROR: INVALID COMMAND.\n\r>', 0
     523A2049
     4E56414C
     49442043
     4F4D4D41
     4E442E0A
     0D3E00
0127 0A0D4552    78   InputErrorStr: db '\n\rERROR: INVALID INPUT. ENTER A NUMBER 0-255.\n\r>', 0
     524F523A
     20494E56
     414C4944
     20494E50
     55542E20
     454E5445
     52204120
     4E554D42
     45522030
     2D323535
     2E0A0D3E
     00
0158 50617261    79   SoakTempStr:db 'Param SOAK TEMP? =',0
     6D20534F
     414B2054
     454D503F
     203D00
016B 50617261    80   SoakTimeStr:db 'Param SOAK TIME? =',0
     6D20534F
     414B2054
     494D453F
     203D00
017E 50617261    81   ReflTempStr:db 'Param REFLOW TEMP? =',0
     6D205245
     464C4F57
     2054454D
     503F203D
     00
0193 50617261    82   ReflTimeStr:db 'Param REFLOW TIME? =',0
     6D205245
     464C4F57
     2054494D
     453F203D
     00
01A8 0A0D5061    83   SavedStr:   db '\n\rParameter saved.\n\r>',0
     72616D65
     74657220
     73617665
     642E0A0D
     3E00
01BE             84   
01BE             85   InitSerialPort:
01BE 75CBFF      86            mov RCAP2H, #HIGH(TIMER_2_RELOAD);
01C1 75CAF7      87            mov RCAP2L, #LOW(TIMER_2_RELOAD);
01C4 75C834      88            mov T2CON, #0x34 ; // #00110100B
01C7 759852      89            mov SCON, #0x52 ; // Serial port in mode 1, ren, txrdy, rxempty
01CA 22          90            ret
01CB             91   
01CB             92   putchar:
01CB 3099FD      93       JNB TI, putchar
01CE C299        94       CLR TI
01D0 F599        95       MOV SBUF, a
01D2 22          96       RET
01D3             97       
01D3             98   SendString:
01D3 E4          99       CLR A
01D4 93         100       MOVC A, @A+DPTR
01D5 6006       101       JZ SSDone
01D7 1201CB     102       LCALL putchar
01DA A3         103       INC DPTR
01DB 80F6       104       SJMP SendString
01DD            105   SSDone:
01DD 22         106       ret
01DE            107   
01DE            108   Initialize_PS2:
01DE            109            ;Configure serial protocol for PS/2
01DE D2B3       110            setb PS2_DAT
01E0 D288       111            setb IT0         ;Setting IT0 makes external interrupts edge-triggered rather than state-triggered
01E2 D2A8       112            setb EX0         ;Enable external interrupts
01E4 D2AF       113            setb EA          ;Enable interrupts
01E6 7800       114            mov R0, #0               ;Stores what bit we're reading
01E8 7900       115            mov R1, #0               ;Stores values of data
01EA C200       116            clr RELEASE_FLAG
01EC C201       117            clr SET_FLAG
01EE C206       118            clr INPUTTING
01F0 C207       119            clr PROMPT_PENDING
01F2 C208       120            clr GET_PARAM
01F4            121            ; Initialize input buffer
01F4 753400     122            mov InputBuffer, #0
01F7 753500     123            mov InputBuffer+1, #0
01FA 753600     124            mov InputBuffer+2, #0
01FD 22         125            ret
01FE            126            
01FE            127   Scancode_To_ASCII:
01FE 900030     128            mov DPTR, #ASCII_TABLE
0201 93         129            movc A, @A+DPTR
0202 22         130            ret
0203            131   
0203            132   Update_HEX_Display:
0203            133            ; Display "C" (0xC6) for temperature or "S" (0x92) for time
0203 200304     134            jb PARAM, Show_S
0206            135            ; Show "C" for temperature
0206 7591C6     136            mov HEX0, #0xC6
0209 22         137            ret
020A            138   Show_S:
020A            139            ; Show "S" for time
020A 759192     140            mov HEX0, #0x92
020D 22         141            ret
020E            142   
020E            143   ; Clear input buffer
020E            144   ClearInputBuffer:
020E 753400     145            mov InputBuffer, #0
0211 753500     146            mov InputBuffer+1, #0
0214 753600     147            mov InputBuffer+2, #0
0217 22         148            ret
0218            149   
0218            150   ; Add ASCII character to input buffer
0218            151   ; Input: A contains ASCII character
0218            152   ; Just stores it in the buffer, no validation
0218            153   AddToBuffer:
0218            154            ; Check if buffer already has 3 characters
0218 AA36       155            mov R2, InputBuffer+2
021A BA0013     156            cjne R2, #0, BufferFull
021D AA35       157            mov R2, InputBuffer+1
021F BA000B     158            cjne R2, #0, AddThird
0222 AA34       159            mov R2, InputBuffer
0224 BA0003     160            cjne R2, #0, AddSecond
0227            161            ; First character
0227 F534       162            mov InputBuffer, A
0229 22         163            ret
022A            164   AddSecond:
022A            165            ; Second character  
022A F535       166            mov InputBuffer+1, A
022C 22         167            ret
022D            168   AddThird:
022D            169            ; Third character
022D F536       170            mov InputBuffer+2, A
022F 22         171            ret
0230            172   BufferFull:
0230            173            ; Already have 3 characters, can't add more (will check on Enter)
0230 22         174            ret
0231            175   
0231            176   ; Validate and convert input buffer to number
0231            177   ; Returns: A = converted number (0-255), CY = 1 if error
0231            178   ValidateAndConvert:
0231            179            ; Check if buffer is empty
0231 E534       180            mov A, InputBuffer
0233 6053       181            jz EmptyInput
0235            182            
0235            183            ; Check if first character is a digit
0235 E534       184            mov A, InputBuffer
0237 12028A     185            lcall CheckDigit
023A 404C       186            jc ValidationError
023C FC         187            mov R4, A              ; Save first digit value in R4
023D            188            
023D            189            ; Check if there's a second character
023D E535       190            mov A, InputBuffer+1
023F 6044       191            jz SingleDigit        ; Only one digit
0241            192            
0241            193            ; Check if second character is a digit
0241 12028A     194            lcall CheckDigit
0244 4042       195            jc ValidationError
0246 FD         196            mov R5, A             ; Save second digit value in R5
0247            197            
0247            198            ; Check if there's a third character
0247 E536       199            mov A, InputBuffer+2
0249 6030       200            jz TwoDigits          ; Only two digits
024B            201            
024B            202            ; Check if third character is a digit
024B 12028A     203            lcall CheckDigit
024E 4038       204            jc ValidationError
0250 FE         205            mov R6, A             ; Save third digit value in R6
0251            206            
0251            207            ; Calculate: first_digit * 100 + second_digit * 10 + third_digit
0251 EC         208            mov A, R4             ; Get first digit
0252 75F064     209            mov B, #100
0255 A4         210            mul AB                ; A = first_digit * 100, B = overflow
0256            211            ; Check if multiplication overflowed (B should be 0 unless first_digit >= 3)
0256 FF         212            mov R7, A             ; Save result (first * 100)
0257 E5F0       213            mov A, B
0259 700F       214            jnz CheckValid3Digit  ; If B != 0, need to validate carefully
025B            215            
025B            216   Add2ndAnd3rdDigits:
025B            217            ; Add second_digit * 10
025B ED         218            mov A, R5
025C 75F00A     219            mov B, #10
025F A4         220            mul AB
0260 2F         221            add A, R7             ; Add to running total
0261 4025       222            jc ValidationError    ; Overflow
0263 FF         223            mov R7, A
0264            224            
0264            225            ; Add third digit
0264 EF         226            mov A, R7
0265 2E         227            add A, R6
0266 4020       228            jc ValidationError    ; Overflow
0268            229            
0268            230            ; Final result in A
0268 C3         231            clr C
0269 22         232            ret
026A            233   
026A            234   CheckValid3Digit:
026A            235            ; First digit is >= 3, could be 200-299, need to validate
026A            236            ; Only 200-255 are valid
026A EC         237            mov A, R4
026B B4021A     238            cjne A, #2, ValidationError  ; If first digit != 2, it's > 255
026E            239            ; First digit is 2, check if 2XX <= 255
026E            240            ; This means second_digit * 10 + third_digit <= 55
026E ED         241            mov A, R5
026F 75F00A     242            mov B, #10
0272 A4         243            mul AB
0273 2E         244            add A, R6
0274            245            ; A now has the last two digits as a number
0274 C3         246            clr C
0275 9438       247            subb A, #56           ; Check if > 55
0277 500F       248            jnc ValidationError   ; If >= 56, then 2XX > 255
0279            249            ; Valid! Calculate actual value
0279 80E0       250            sjmp Add2ndAnd3rdDigits
027B            251   
027B            252   TwoDigits:
027B            253            ; Calculate: first_digit * 10 + second_digit
027B EC         254            mov A, R4             ; Get first digit
027C 75F00A     255            mov B, #10
027F A4         256            mul AB                ; A = first_digit * 10
0280 2D         257            add A, R5             ; Add second digit
0281 4005       258            jc ValidationError    ; Overflow (shouldn't happen with 2 digits)
0283 C3         259            clr C
0284 22         260            ret
0285            261   
0285            262   SingleDigit:
0285 EC         263            mov A, R4             ; Single digit value
0286 C3         264            clr C
0287 22         265            ret
0288            266   
0288            267   EmptyInput:
0288            268   ValidationError:
0288 D3         269            setb C
0289 22         270            ret
028A            271   
028A            272   ; Check if ASCII character in A is a digit ('0'-'9')
028A            273   ; Returns: A = numeric value (0-9), CY = 1 if not a digit
028A            274   CheckDigit:
028A C3         275            clr C
028B 9430       276            subb A, #'0'
028D 400B       277            jc NotDigit           ; Less than '0'
028F            278            ; A now contains value 0-? 
028F F5F0       279            mov B, A
0291 C3         280            clr C
0292 940A       281            subb A, #10           ; Check if >= 10
0294 5004       282            jnc NotDigit          ; If A >= 10, not a digit
0296 E5F0       283            mov A, B              ; Restore numeric value (0-9)
0298 C3         284            clr C
0299 22         285            ret
029A            286   NotDigit:
029A D3         287            setb C
029B 22         288            ret
029C            289   
029C            290   ; Display number in A as decimal ASCII
029C            291   ; Input: A = number (0-255)
029C            292   DisplayNumber:
029C 75F064     293            mov B, #100
029F 84         294            div AB                ; A = hundreds, B = remainder
02A0 AAF0       295            mov R2, B             ; Save remainder
02A2 F5F0       296            mov B, A              ; Save hundreds digit
02A4            297            
02A4            298            ; Check if we need to display hundreds
02A4 E5F0       299            mov A, B
02A6 6005       300            jz SkipHundreds
02A8 2430       301            add A, #'0'
02AA 1201CB     302            lcall putchar
02AD            303            
02AD            304   SkipHundreds:
02AD            305            ; Get tens digit
02AD EA         306            mov A, R2             ; Get remainder
02AE 75F00A     307            mov B, #10
02B1 84         308            div AB                ; A = tens, B = ones
02B2 ABF0       309            mov R3, B             ; Save ones digit
02B4            310            
02B4            311            ; Display tens (if hundreds was shown, or if tens > 0)
02B4 F5F0       312            mov B, A              ; Save tens
02B6 EA         313            mov A, R2
02B7 7A64       314            mov R2, #100
02B9 C3         315            clr C
02BA 9A         316            subb A, R2
02BB 5004       317            jnc ShowTens          ; If original remainder >= 100, show tens
02BD E5F0       318            mov A, B
02BF 6007       319            jz SkipTens           ; If no hundreds and tens = 0, skip
02C1            320            
02C1            321   ShowTens:
02C1 E5F0       322            mov A, B
02C3 2430       323            add A, #'0'
02C5 1201CB     324            lcall putchar
02C8            325            
02C8            326   SkipTens:
02C8            327            ; Always display ones digit
02C8 EB         328            mov A, R3
02C9 2430       329            add A, #'0'
02CB 1201CB     330            lcall putchar
02CE 22         331            ret
02CF            332   
02CF            333   ; Get the currently selected parameter value
02CF            334   ; Returns: A = parameter value
02CF            335   GetCurrentParam:
02CF 200209     336            jb MODE, GetReflowParam
02D2            337            ; MODE = 0: Soak
02D2 200303     338            jb PARAM, GetSoakTime
02D5 E530       339            mov A, SoakTemp
02D7 22         340            ret
02D8            341   GetSoakTime:
02D8 E531       342            mov A, SoakTime
02DA 22         343            ret
02DB            344   GetReflowParam:
02DB            345            ; MODE = 1: Reflow
02DB 200303     346            jb PARAM, GetReflowTime
02DE E532       347            mov A, ReflowTemp
02E0 22         348            ret
02E1            349   GetReflowTime:
02E1 E533       350            mov A, ReflowTime
02E3 22         351            ret
02E4            352   
02E4            353   ; Save the input buffer to the appropriate parameter variable
02E4            354   SaveInputToParam:
02E4            355            ; First validate and convert the input
02E4 120231     356            lcall ValidateAndConvert
02E7 4028       357            jc SaveError          ; If CY = 1, validation failed
02E9            358            
02E9            359            ; A contains the valid number (0-255)
02E9 FA         360            mov R2, A             ; Save the value
02EA            361            
02EA 20020D     362            jb MODE, SaveReflowParam
02ED            363            ; MODE = 0: Soak
02ED 200305     364            jb PARAM, SaveSoakTime
02F0            365            ; Save to SoakTemp
02F0 EA         366            mov A, R2
02F1 F530       367            mov SoakTemp, A
02F3 8010       368            sjmp ParamSaved
02F5            369   SaveSoakTime:
02F5 EA         370            mov A, R2
02F6 F531       371            mov SoakTime, A
02F8 800B       372            sjmp ParamSaved
02FA            373   SaveReflowParam:
02FA            374            ; MODE = 1: Reflow
02FA 200305     375            jb PARAM, SaveReflowTime
02FD            376            ; Save to ReflowTemp
02FD EA         377            mov A, R2
02FE F532       378            mov ReflowTemp, A
0300 8003       379            sjmp ParamSaved
0302            380   SaveReflowTime:
0302 EA         381            mov A, R2
0303 F533       382            mov ReflowTime, A
0305            383   ParamSaved:
0305 9001A8     384            mov dptr, #SavedStr
0308 1201D3     385            lcall SendString
030B C206       386            clr INPUTTING
030D 12020E     387            lcall ClearInputBuffer
0310 22         388            ret
0311            389   
0311            390   SaveError:
0311            391            ; Check if empty or invalid
0311 E534       392            mov A, InputBuffer
0313 600A       393            jz EmptyError
0315            394            ; Invalid/overflow error
0315 900127     395            mov dptr, #InputErrorStr
0318 1201D3     396            lcall SendString
031B 12020E     397            lcall ClearInputBuffer
031E 22         398            ret
031F            399   EmptyError:
031F 900127     400            mov dptr, #InputErrorStr
0322 1201D3     401            lcall SendString
0325 22         402            ret
0326            403            
0326            404   PS2_Interrupt:
0326 C0E0       405            push ACC
0328 C0D0       406            push PSW
032A            407            
032A E8         408            mov A, R0
032B            409            ;If we're at the start of a frame, validate start bit before incrementing
032B B40004     410            cjne A, #0, NotAtStart
032E A2B3       411            mov C, PS2_DAT
0330 4008       412            jc jump    ;If start bit is 1, wait for valid start (should be 0)
0332            413            
0332            414   NotAtStart:
0332 08         415            inc R0
0333 E8         416            mov A, R0
0334            417            ;Ignore start bit
0334 B40106     418            cjne A, #1, CheckData
0337 02049A     419            ljmp PS2_Done
033A            420            
033A            421   jump:
033A 02049A     422            ljmp PS2_Done
033D            423            
033D            424   CheckData:
033D            425            ;Read data bits
033D C3         426            clr C
033E 940A       427            subb A, #10      ;Carry if A < 10 (bits 2-9)
0340 5012       428            jnc CheckIfDoneJump
0342 A2B3       429            mov C, PS2_DAT   ;Read data line
0344 E9         430            mov A, R1
0345 13         431            rrc A            ;Shift into R1
0346 F9         432            mov R1, A
0347 E8         433            mov A, R0
0348 B409EF     434            cjne A, #9, jump
034B E9         435            mov A, R1
034C B4F008     436            cjne A, #0F0h, NotRelease
034F D200       437            setb RELEASE_FLAG ;stop code
0351 02049A     438            ljmp PS2_Done
0354            439   CheckIfDoneJump:
0354 020488     440            ljmp CheckIfDone
0357            441   NotRelease:
0357 200013     442            jb RELEASE_FLAG, ClearRelJump
035A 1201FE     443            lcall Scancode_To_ASCII
035D 60DB       444            jz jump
035F F5E8       445            mov LEDRA, A  
0361            446            
0361            447            ; Check if we're in number input mode
0361 300615     448            jnb INPUTTING, NotInputtingNum
0364            449            ; We're inputting a number - just accumulate characters
0364 B40A09     450            cjne A, #0Ah, JustAddChar
0367            451            ; Enter key pressed - validate and save the value
0367 1202E4     452            lcall SaveInputToParam
036A 02049A     453            ljmp PS2_Done
036D            454            
036D            455   ClearRelJump:
036D 020484     456            ljmp ClearRel
0370            457   JustAddChar:
0370            458            ; Just echo the character and add to buffer (no validation yet)
0370 1201CB     459            lcall putchar
0373 120218     460            lcall AddToBuffer
0376 02049A     461            ljmp PS2_Done
0379            462            
0379            463   NotInputtingNum:
0379            464            ; Check if we need to show a prompt (Enter pressed after 't' or 'x')
0379 B40A1B     465            cjne A, #0Ah, NotEnterJump
037C            466            ; Enter key pressed
037C 30073E     467            jnb PROMPT_PENDING, CheckGetParam
037F            468            ; We need to show the parameter prompt
037F 740A       469            mov A, #0Ah    
0381 1201CB     470            lcall putchar
0384 740D       471            mov A, #'\r'   
0386 1201CB     472            lcall putchar
0389            473            ; Show the appropriate prompt based on MODE and PARAM
0389 200216     474            jb MODE, ShowReflowPrompt
038C 20030B     475            jb PARAM, ShowSoakTimePrompt
038F 900158     476            mov dptr, #SoakTempStr
0392 1201D3     477            lcall SendString
0395 801C       478            sjmp StartInputMode
0397            479   NotEnterJump:
0397 020435     480            ljmp NotEnter
039A            481   ShowSoakTimePrompt:
039A 90016B     482            mov dptr, #SoakTimeStr
039D 1201D3     483            lcall SendString
03A0 8011       484            sjmp StartInputMode
03A2            485   ShowReflowPrompt:
03A2 200308     486            jb PARAM, ShowReflowTimePrompt
03A5 90017E     487            mov dptr, #ReflTempStr
03A8 1201D3     488            lcall SendString
03AB 8006       489            sjmp StartInputMode
03AD            490   ShowReflowTimePrompt:
03AD 900193     491            mov dptr, #ReflTimeStr
03B0 1201D3     492            lcall SendString
03B3            493   StartInputMode:
03B3 D206       494            setb INPUTTING
03B5 C207       495            clr PROMPT_PENDING
03B7 12020E     496            lcall ClearInputBuffer
03BA 02049A     497            ljmp PS2_Done
03BD            498   
03BD            499   CheckGetParam:
03BD            500            ; Check if we need to display current parameter value
03BD 30084B     501            jnb GET_PARAM, NormalEnter
03C0            502            ; Display the current parameter
03C0 740A       503            mov A, #0Ah    
03C2 1201CB     504            lcall putchar
03C5 740D       505            mov A, #'\r'   
03C7 1201CB     506            lcall putchar
03CA            507            ; Show parameter name
03CA 200213     508            jb MODE, ShowReflowParamName
03CD 200308     509            jb PARAM, ShowSoakTimeName
03D0 900158     510            mov dptr, #SoakTempStr
03D3 1201D3     511            lcall SendString
03D6 8019       512            sjmp ShowParamValue
03D8            513   ShowSoakTimeName:
03D8 90016B     514            mov dptr, #SoakTimeStr
03DB 1201D3     515            lcall SendString
03DE 8011       516            sjmp ShowParamValue
03E0            517   ShowReflowParamName:
03E0 200308     518            jb PARAM, ShowReflowTimeName
03E3 90017E     519            mov dptr, #ReflTempStr
03E6 1201D3     520            lcall SendString
03E9 8006       521            sjmp ShowParamValue
03EB            522   ShowReflowTimeName:
03EB 900193     523            mov dptr, #ReflTimeStr
03EE 1201D3     524            lcall SendString
03F1            525   ShowParamValue:
03F1 1202CF     526            lcall GetCurrentParam
03F4 12029C     527            lcall DisplayNumber
03F7 740A       528            mov A, #0Ah    
03F9 1201CB     529            lcall putchar
03FC 740D       530            mov A, #'\r'   
03FE 1201CB     531            lcall putchar
0401 743E       532            mov A, #'>'
0403 1201CB     533            lcall putchar
0406 C208       534            clr GET_PARAM
0408 02049A     535            ljmp PS2_Done
040B            536            
040B            537   NormalEnter:
040B            538            ; Normal Enter handling (not after 't' or 'x')
040B 740A       539            mov A, #0Ah    
040D 1201CB     540            lcall putchar
0410 740D       541            mov A, #'\r'   
0412 1201CB     542            lcall putchar
0415 743E       543            mov A, #'>'     
0417 1201CB     544            lcall putchar
041A 200406     545            jb INVALID, Error
041D 30010D     546            jnb SET_FLAG, Warning
0420 02049A     547            ljmp PS2_Done
0423            548            
0423            549   Error:
0423 90010C     550            mov dptr, #ErrorStr
0426 1201D3     551            lcall SendString
0429 C204       552            clr INVALID
042B 806D       553            sjmp PS2_Done
042D            554            
042D            555   Warning:
042D 9000C0     556            mov dptr, #WarningStr
0430 1201D3     557            lcall SendString
0433 8065       558            sjmp PS2_Done
0435            559            
0435            560   NotEnter:
0435 1201CB     561            lcall putchar
0438 B47104     562            cjne A, #'q', NotQ
043B C201       563            clr SET_FLAG
043D 805B       564            sjmp PS2_Done
043F            565   
043F            566   NotQ:
043F D205       567            setb AWAIT
0441 200107     568            jb SET_FLAG, Setting
0444 B46353     569            cjne A, #'c', PS2_Done
0447 D201       570            setb SET_FLAG
0449 804F       571            sjmp PS2_Done
044B            572            
044B            573   Setting:
044B B47307     574            cjne A, #'s', CheckR
044E C202       575            clr MODE
0450 759502     576            mov LEDRB, #0b10  ; Show 10 for Soak
0453 8045       577            sjmp PS2_Done
0455            578            
0455            579   CheckR:
0455 B47209     580            cjne A, #'r', CheckT
0458 D202       581            setb MODE
045A 759501     582            mov LEDRB, #0b01  ; Show 01 for Reflow
045D D205       583            setb AWAIT
045F 8039       584            sjmp PS2_Done
0461            585            
0461            586   CheckT:
0461 B47409     587            cjne A, #'t', CheckX
0464 D203       588            setb PARAM
0466 120203     589            lcall Update_HEX_Display
0469 D207       590            setb PROMPT_PENDING   ; Will prompt on next Enter
046B 802D       591            sjmp PS2_Done
046D            592            
046D            593   CheckX:
046D B47809     594            cjne A, #'x', CheckG
0470 C203       595            clr PARAM
0472 120203     596            lcall Update_HEX_Display
0475 D207       597            setb PROMPT_PENDING   ; Will prompt on next Enter
0477 8021       598            sjmp PS2_Done
0479            599   
0479            600   CheckG:
0479 B46704     601            cjne A, #'g', InvalidHandler
047C D208       602            setb GET_PARAM        ; Will display current parameter on next Enter
047E 801A       603            sjmp PS2_Done
0480            604   
0480            605   InvalidHandler:
0480 D204       606            setb INVALID
0482 8016       607            sjmp PS2_Done
0484            608            
0484            609   ClearRel:
0484 C200       610            clr RELEASE_FLAG 
0486 8012       611            sjmp PS2_Done
0488            612   CheckIfDone:
0488            613            ;Wait for Stop Bit
0488 B40B08     614            cjne A, #11, CheckOverflow
048B 8000       615            sjmp Reset
048D            616            
048D            617   Reset:
048D            618            ;Resets so we're ready for next keypress
048D 7800       619            mov R0, #0
048F 7900       620            mov R1, #0
0491 8007       621            sjmp PS2_Done
0493            622   CheckOverflow:
0493            623            ;Prevents from going out of sync (this was a problem because we're not explicitly checking the parity bit)
0493 C3         624            clr C
0494 940C       625            subb A, #12
0496 4002       626            jc PS2_Done
0498 80F3       627            sjmp Reset
049A            628   PS2_Done:
049A D0D0       629            pop PSW
049C D0E0       630            pop ACC
049E 32         631            reti
049F            632   MainProgram:
049F 75E800     633            mov LEDRA, #0X00
04A2 759500     634            mov LEDRB, #0x00
04A5 7591C6     635            mov HEX0, #0xC6  ; Initialize to "C" (temperature)
04A8 75817F     636       mov sp, #0x7f
04AB 740D       637       mov A, #'\r'
04AD 1201DE     638       lcall Initialize_PS2
04B0 1201BE     639       lcall InitSerialPort
04B3 1201CB     640       lcall putchar
04B6 740A       641            mov A, #'\n'
04B8 1201CB     642            lcall putchar
04BB 743E       643       mov A, #'>'
04BD 1201CB     644       lcall putchar
04C0            645   forever:
04C0 80FE       646            sjmp forever
04C2            647            
04C2            648            
04C2            649   
04C2            650   en
